// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.33.0
// source: drm/widevine/cdm/widevine.proto

package cdm

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type LicenseType int32

const (
	LicenseType_STREAMING LicenseType = 1
	LicenseType_OFFLINE   LicenseType = 2
)

// Enum value maps for LicenseType.
var (
	LicenseType_name = map[int32]string{
		1: "STREAMING",
		2: "OFFLINE",
	}
	LicenseType_value = map[string]int32{
		"STREAMING": 1,
		"OFFLINE":   2,
	}
)

func (x LicenseType) Enum() *LicenseType {
	p := new(LicenseType)
	*p = x
	return p
}

func (x LicenseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LicenseType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[0].Descriptor()
}

func (LicenseType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[0]
}

func (x LicenseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *LicenseType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = LicenseType(num)
	return nil
}

// Deprecated: Use LicenseType.Descriptor instead.
func (LicenseType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{0}
}

type ProtocolVersion int32

const (
	ProtocolVersion_VERSION_2_0 ProtocolVersion = 20
	ProtocolVersion_VERSION_2_1 ProtocolVersion = 21
)

// Enum value maps for ProtocolVersion.
var (
	ProtocolVersion_name = map[int32]string{
		20: "VERSION_2_0",
		21: "VERSION_2_1",
	}
	ProtocolVersion_value = map[string]int32{
		"VERSION_2_0": 20,
		"VERSION_2_1": 21,
	}
)

func (x ProtocolVersion) Enum() *ProtocolVersion {
	p := new(ProtocolVersion)
	*p = x
	return p
}

func (x ProtocolVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProtocolVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[1].Descriptor()
}

func (ProtocolVersion) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[1]
}

func (x ProtocolVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ProtocolVersion) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ProtocolVersion(num)
	return nil
}

// Deprecated: Use ProtocolVersion.Descriptor instead.
func (ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{1}
}

type WidevineCencHeader_Algorithm int32

const (
	WidevineCencHeader_UNENCRYPTED WidevineCencHeader_Algorithm = 0
	WidevineCencHeader_AESCTR      WidevineCencHeader_Algorithm = 1
)

// Enum value maps for WidevineCencHeader_Algorithm.
var (
	WidevineCencHeader_Algorithm_name = map[int32]string{
		0: "UNENCRYPTED",
		1: "AESCTR",
	}
	WidevineCencHeader_Algorithm_value = map[string]int32{
		"UNENCRYPTED": 0,
		"AESCTR":      1,
	}
)

func (x WidevineCencHeader_Algorithm) Enum() *WidevineCencHeader_Algorithm {
	p := new(WidevineCencHeader_Algorithm)
	*p = x
	return p
}

func (x WidevineCencHeader_Algorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WidevineCencHeader_Algorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[2].Descriptor()
}

func (WidevineCencHeader_Algorithm) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[2]
}

func (x WidevineCencHeader_Algorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *WidevineCencHeader_Algorithm) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = WidevineCencHeader_Algorithm(num)
	return nil
}

// Deprecated: Use WidevineCencHeader_Algorithm.Descriptor instead.
func (WidevineCencHeader_Algorithm) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{0, 0}
}

type License_KeyContainer_KeyType int32

const (
	// Exactly one key of this type must appear.
	License_KeyContainer_SIGNING          License_KeyContainer_KeyType = 1
	License_KeyContainer_CONTENT          License_KeyContainer_KeyType = 2
	License_KeyContainer_KEY_CONTROL      License_KeyContainer_KeyType = 3
	License_KeyContainer_OPERATOR_SESSION License_KeyContainer_KeyType = 4
)

// Enum value maps for License_KeyContainer_KeyType.
var (
	License_KeyContainer_KeyType_name = map[int32]string{
		1: "SIGNING",
		2: "CONTENT",
		3: "KEY_CONTROL",
		4: "OPERATOR_SESSION",
	}
	License_KeyContainer_KeyType_value = map[string]int32{
		"SIGNING":          1,
		"CONTENT":          2,
		"KEY_CONTROL":      3,
		"OPERATOR_SESSION": 4,
	}
)

func (x License_KeyContainer_KeyType) Enum() *License_KeyContainer_KeyType {
	p := new(License_KeyContainer_KeyType)
	*p = x
	return p
}

func (x License_KeyContainer_KeyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (License_KeyContainer_KeyType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[3].Descriptor()
}

func (License_KeyContainer_KeyType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[3]
}

func (x License_KeyContainer_KeyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *License_KeyContainer_KeyType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = License_KeyContainer_KeyType(num)
	return nil
}

// Deprecated: Use License_KeyContainer_KeyType.Descriptor instead.
func (License_KeyContainer_KeyType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 0}
}

// The SecurityLevel enumeration allows the server to communicate the level
// of robustness required by the client, in order to use the key.
type License_KeyContainer_SecurityLevel int32

const (
	// Software-based whitebox crypto is required.
	License_KeyContainer_SW_SECURE_CRYPTO License_KeyContainer_SecurityLevel = 1
	// Software crypto and an obfuscated decoder is required.
	License_KeyContainer_SW_SECURE_DECODE License_KeyContainer_SecurityLevel = 2
	// The key material and crypto operations must be performed within a
	// hardware backed trusted execution environment.
	License_KeyContainer_HW_SECURE_CRYPTO License_KeyContainer_SecurityLevel = 3
	// The crypto and decoding of content must be performed within a hardware
	// backed trusted execution environment.
	License_KeyContainer_HW_SECURE_DECODE License_KeyContainer_SecurityLevel = 4
	// The crypto, decoding and all handling of the media (compressed and
	// uncompressed) must be handled within a hardware backed trusted
	// execution environment.
	License_KeyContainer_HW_SECURE_ALL License_KeyContainer_SecurityLevel = 5
)

// Enum value maps for License_KeyContainer_SecurityLevel.
var (
	License_KeyContainer_SecurityLevel_name = map[int32]string{
		1: "SW_SECURE_CRYPTO",
		2: "SW_SECURE_DECODE",
		3: "HW_SECURE_CRYPTO",
		4: "HW_SECURE_DECODE",
		5: "HW_SECURE_ALL",
	}
	License_KeyContainer_SecurityLevel_value = map[string]int32{
		"SW_SECURE_CRYPTO": 1,
		"SW_SECURE_DECODE": 2,
		"HW_SECURE_CRYPTO": 3,
		"HW_SECURE_DECODE": 4,
		"HW_SECURE_ALL":    5,
	}
)

func (x License_KeyContainer_SecurityLevel) Enum() *License_KeyContainer_SecurityLevel {
	p := new(License_KeyContainer_SecurityLevel)
	*p = x
	return p
}

func (x License_KeyContainer_SecurityLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (License_KeyContainer_SecurityLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[4].Descriptor()
}

func (License_KeyContainer_SecurityLevel) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[4]
}

func (x License_KeyContainer_SecurityLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *License_KeyContainer_SecurityLevel) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = License_KeyContainer_SecurityLevel(num)
	return nil
}

// Deprecated: Use License_KeyContainer_SecurityLevel.Descriptor instead.
func (License_KeyContainer_SecurityLevel) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 1}
}

// Indicates whether HDCP is required on digital outputs, and which
// version should be used.
type License_KeyContainer_OutputProtection_HDCP int32

const (
	License_KeyContainer_OutputProtection_HDCP_NONE              License_KeyContainer_OutputProtection_HDCP = 0
	License_KeyContainer_OutputProtection_HDCP_V1                License_KeyContainer_OutputProtection_HDCP = 1
	License_KeyContainer_OutputProtection_HDCP_V2                License_KeyContainer_OutputProtection_HDCP = 2
	License_KeyContainer_OutputProtection_HDCP_V2_1              License_KeyContainer_OutputProtection_HDCP = 3
	License_KeyContainer_OutputProtection_HDCP_V2_2              License_KeyContainer_OutputProtection_HDCP = 4
	License_KeyContainer_OutputProtection_HDCP_NO_DIGITAL_OUTPUT License_KeyContainer_OutputProtection_HDCP = 255
)

// Enum value maps for License_KeyContainer_OutputProtection_HDCP.
var (
	License_KeyContainer_OutputProtection_HDCP_name = map[int32]string{
		0:   "HDCP_NONE",
		1:   "HDCP_V1",
		2:   "HDCP_V2",
		3:   "HDCP_V2_1",
		4:   "HDCP_V2_2",
		255: "HDCP_NO_DIGITAL_OUTPUT",
	}
	License_KeyContainer_OutputProtection_HDCP_value = map[string]int32{
		"HDCP_NONE":              0,
		"HDCP_V1":                1,
		"HDCP_V2":                2,
		"HDCP_V2_1":              3,
		"HDCP_V2_2":              4,
		"HDCP_NO_DIGITAL_OUTPUT": 255,
	}
)

func (x License_KeyContainer_OutputProtection_HDCP) Enum() *License_KeyContainer_OutputProtection_HDCP {
	p := new(License_KeyContainer_OutputProtection_HDCP)
	*p = x
	return p
}

func (x License_KeyContainer_OutputProtection_HDCP) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (License_KeyContainer_OutputProtection_HDCP) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[5].Descriptor()
}

func (License_KeyContainer_OutputProtection_HDCP) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[5]
}

func (x License_KeyContainer_OutputProtection_HDCP) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *License_KeyContainer_OutputProtection_HDCP) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = License_KeyContainer_OutputProtection_HDCP(num)
	return nil
}

// Deprecated: Use License_KeyContainer_OutputProtection_HDCP.Descriptor instead.
func (License_KeyContainer_OutputProtection_HDCP) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 1, 0}
}

// Indicate the CGMS setting to be inserted on analog output.
type License_KeyContainer_OutputProtection_CGMS int32

const (
	License_KeyContainer_OutputProtection_CGMS_NONE  License_KeyContainer_OutputProtection_CGMS = 42
	License_KeyContainer_OutputProtection_COPY_FREE  License_KeyContainer_OutputProtection_CGMS = 0
	License_KeyContainer_OutputProtection_COPY_ONCE  License_KeyContainer_OutputProtection_CGMS = 2
	License_KeyContainer_OutputProtection_COPY_NEVER License_KeyContainer_OutputProtection_CGMS = 3
)

// Enum value maps for License_KeyContainer_OutputProtection_CGMS.
var (
	License_KeyContainer_OutputProtection_CGMS_name = map[int32]string{
		42: "CGMS_NONE",
		0:  "COPY_FREE",
		2:  "COPY_ONCE",
		3:  "COPY_NEVER",
	}
	License_KeyContainer_OutputProtection_CGMS_value = map[string]int32{
		"CGMS_NONE":  42,
		"COPY_FREE":  0,
		"COPY_ONCE":  2,
		"COPY_NEVER": 3,
	}
)

func (x License_KeyContainer_OutputProtection_CGMS) Enum() *License_KeyContainer_OutputProtection_CGMS {
	p := new(License_KeyContainer_OutputProtection_CGMS)
	*p = x
	return p
}

func (x License_KeyContainer_OutputProtection_CGMS) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (License_KeyContainer_OutputProtection_CGMS) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[6].Descriptor()
}

func (License_KeyContainer_OutputProtection_CGMS) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[6]
}

func (x License_KeyContainer_OutputProtection_CGMS) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *License_KeyContainer_OutputProtection_CGMS) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = License_KeyContainer_OutputProtection_CGMS(num)
	return nil
}

// Deprecated: Use License_KeyContainer_OutputProtection_CGMS.Descriptor instead.
func (License_KeyContainer_OutputProtection_CGMS) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 1, 1}
}

type LicenseRequest_RequestType int32

const (
	LicenseRequest_NEW     LicenseRequest_RequestType = 1
	LicenseRequest_RENEWAL LicenseRequest_RequestType = 2
	LicenseRequest_RELEASE LicenseRequest_RequestType = 3
)

// Enum value maps for LicenseRequest_RequestType.
var (
	LicenseRequest_RequestType_name = map[int32]string{
		1: "NEW",
		2: "RENEWAL",
		3: "RELEASE",
	}
	LicenseRequest_RequestType_value = map[string]int32{
		"NEW":     1,
		"RENEWAL": 2,
		"RELEASE": 3,
	}
)

func (x LicenseRequest_RequestType) Enum() *LicenseRequest_RequestType {
	p := new(LicenseRequest_RequestType)
	*p = x
	return p
}

func (x LicenseRequest_RequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LicenseRequest_RequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[7].Descriptor()
}

func (LicenseRequest_RequestType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[7]
}

func (x LicenseRequest_RequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *LicenseRequest_RequestType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = LicenseRequest_RequestType(num)
	return nil
}

// Deprecated: Use LicenseRequest_RequestType.Descriptor instead.
func (LicenseRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3, 0}
}

type SignedMessage_MessageType int32

const (
	SignedMessage_LICENSE_REQUEST             SignedMessage_MessageType = 1
	SignedMessage_LICENSE                     SignedMessage_MessageType = 2
	SignedMessage_ERROR_RESPONSE              SignedMessage_MessageType = 3
	SignedMessage_SERVICE_CERTIFICATE_REQUEST SignedMessage_MessageType = 4
	SignedMessage_SERVICE_CERTIFICATE         SignedMessage_MessageType = 5
)

// Enum value maps for SignedMessage_MessageType.
var (
	SignedMessage_MessageType_name = map[int32]string{
		1: "LICENSE_REQUEST",
		2: "LICENSE",
		3: "ERROR_RESPONSE",
		4: "SERVICE_CERTIFICATE_REQUEST",
		5: "SERVICE_CERTIFICATE",
	}
	SignedMessage_MessageType_value = map[string]int32{
		"LICENSE_REQUEST":             1,
		"LICENSE":                     2,
		"ERROR_RESPONSE":              3,
		"SERVICE_CERTIFICATE_REQUEST": 4,
		"SERVICE_CERTIFICATE":         5,
	}
)

func (x SignedMessage_MessageType) Enum() *SignedMessage_MessageType {
	p := new(SignedMessage_MessageType)
	*p = x
	return p
}

func (x SignedMessage_MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignedMessage_MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[8].Descriptor()
}

func (SignedMessage_MessageType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[8]
}

func (x SignedMessage_MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *SignedMessage_MessageType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = SignedMessage_MessageType(num)
	return nil
}

// Deprecated: Use SignedMessage_MessageType.Descriptor instead.
func (SignedMessage_MessageType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{5, 0}
}

type ClientIdentification_TokenType int32

const (
	ClientIdentification_KEYBOX                         ClientIdentification_TokenType = 0
	ClientIdentification_DEVICE_CERTIFICATE             ClientIdentification_TokenType = 1
	ClientIdentification_REMOTE_ATTESTATION_CERTIFICATE ClientIdentification_TokenType = 2
)

// Enum value maps for ClientIdentification_TokenType.
var (
	ClientIdentification_TokenType_name = map[int32]string{
		0: "KEYBOX",
		1: "DEVICE_CERTIFICATE",
		2: "REMOTE_ATTESTATION_CERTIFICATE",
	}
	ClientIdentification_TokenType_value = map[string]int32{
		"KEYBOX":                         0,
		"DEVICE_CERTIFICATE":             1,
		"REMOTE_ATTESTATION_CERTIFICATE": 2,
	}
)

func (x ClientIdentification_TokenType) Enum() *ClientIdentification_TokenType {
	p := new(ClientIdentification_TokenType)
	*p = x
	return p
}

func (x ClientIdentification_TokenType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClientIdentification_TokenType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[9].Descriptor()
}

func (ClientIdentification_TokenType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[9]
}

func (x ClientIdentification_TokenType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ClientIdentification_TokenType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ClientIdentification_TokenType(num)
	return nil
}

// Deprecated: Use ClientIdentification_TokenType.Descriptor instead.
func (ClientIdentification_TokenType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{6, 0}
}

type ClientIdentification_ClientCapabilities_HdcpVersion int32

const (
	ClientIdentification_ClientCapabilities_HDCP_NONE              ClientIdentification_ClientCapabilities_HdcpVersion = 0
	ClientIdentification_ClientCapabilities_HDCP_V1                ClientIdentification_ClientCapabilities_HdcpVersion = 1
	ClientIdentification_ClientCapabilities_HDCP_V2                ClientIdentification_ClientCapabilities_HdcpVersion = 2
	ClientIdentification_ClientCapabilities_HDCP_V2_1              ClientIdentification_ClientCapabilities_HdcpVersion = 3
	ClientIdentification_ClientCapabilities_HDCP_V2_2              ClientIdentification_ClientCapabilities_HdcpVersion = 4
	ClientIdentification_ClientCapabilities_HDCP_NO_DIGITAL_OUTPUT ClientIdentification_ClientCapabilities_HdcpVersion = 255
)

// Enum value maps for ClientIdentification_ClientCapabilities_HdcpVersion.
var (
	ClientIdentification_ClientCapabilities_HdcpVersion_name = map[int32]string{
		0:   "HDCP_NONE",
		1:   "HDCP_V1",
		2:   "HDCP_V2",
		3:   "HDCP_V2_1",
		4:   "HDCP_V2_2",
		255: "HDCP_NO_DIGITAL_OUTPUT",
	}
	ClientIdentification_ClientCapabilities_HdcpVersion_value = map[string]int32{
		"HDCP_NONE":              0,
		"HDCP_V1":                1,
		"HDCP_V2":                2,
		"HDCP_V2_1":              3,
		"HDCP_V2_2":              4,
		"HDCP_NO_DIGITAL_OUTPUT": 255,
	}
)

func (x ClientIdentification_ClientCapabilities_HdcpVersion) Enum() *ClientIdentification_ClientCapabilities_HdcpVersion {
	p := new(ClientIdentification_ClientCapabilities_HdcpVersion)
	*p = x
	return p
}

func (x ClientIdentification_ClientCapabilities_HdcpVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClientIdentification_ClientCapabilities_HdcpVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[10].Descriptor()
}

func (ClientIdentification_ClientCapabilities_HdcpVersion) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[10]
}

func (x ClientIdentification_ClientCapabilities_HdcpVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *ClientIdentification_ClientCapabilities_HdcpVersion) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = ClientIdentification_ClientCapabilities_HdcpVersion(num)
	return nil
}

// Deprecated: Use ClientIdentification_ClientCapabilities_HdcpVersion.Descriptor instead.
func (ClientIdentification_ClientCapabilities_HdcpVersion) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{6, 1, 0}
}

type SignedLicenseRequest_MessageType int32

const (
	SignedLicenseRequest_LICENSE_REQUEST             SignedLicenseRequest_MessageType = 1
	SignedLicenseRequest_LICENSE                     SignedLicenseRequest_MessageType = 2
	SignedLicenseRequest_ERROR_RESPONSE              SignedLicenseRequest_MessageType = 3
	SignedLicenseRequest_SERVICE_CERTIFICATE_REQUEST SignedLicenseRequest_MessageType = 4
	SignedLicenseRequest_SERVICE_CERTIFICATE         SignedLicenseRequest_MessageType = 5
)

// Enum value maps for SignedLicenseRequest_MessageType.
var (
	SignedLicenseRequest_MessageType_name = map[int32]string{
		1: "LICENSE_REQUEST",
		2: "LICENSE",
		3: "ERROR_RESPONSE",
		4: "SERVICE_CERTIFICATE_REQUEST",
		5: "SERVICE_CERTIFICATE",
	}
	SignedLicenseRequest_MessageType_value = map[string]int32{
		"LICENSE_REQUEST":             1,
		"LICENSE":                     2,
		"ERROR_RESPONSE":              3,
		"SERVICE_CERTIFICATE_REQUEST": 4,
		"SERVICE_CERTIFICATE":         5,
	}
)

func (x SignedLicenseRequest_MessageType) Enum() *SignedLicenseRequest_MessageType {
	p := new(SignedLicenseRequest_MessageType)
	*p = x
	return p
}

func (x SignedLicenseRequest_MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignedLicenseRequest_MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[11].Descriptor()
}

func (SignedLicenseRequest_MessageType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[11]
}

func (x SignedLicenseRequest_MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *SignedLicenseRequest_MessageType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = SignedLicenseRequest_MessageType(num)
	return nil
}

// Deprecated: Use SignedLicenseRequest_MessageType.Descriptor instead.
func (SignedLicenseRequest_MessageType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{8, 0}
}

type SignedLicense_MessageType int32

const (
	SignedLicense_LICENSE_REQUEST             SignedLicense_MessageType = 1
	SignedLicense_LICENSE                     SignedLicense_MessageType = 2
	SignedLicense_ERROR_RESPONSE              SignedLicense_MessageType = 3
	SignedLicense_SERVICE_CERTIFICATE_REQUEST SignedLicense_MessageType = 4
	SignedLicense_SERVICE_CERTIFICATE         SignedLicense_MessageType = 5
)

// Enum value maps for SignedLicense_MessageType.
var (
	SignedLicense_MessageType_name = map[int32]string{
		1: "LICENSE_REQUEST",
		2: "LICENSE",
		3: "ERROR_RESPONSE",
		4: "SERVICE_CERTIFICATE_REQUEST",
		5: "SERVICE_CERTIFICATE",
	}
	SignedLicense_MessageType_value = map[string]int32{
		"LICENSE_REQUEST":             1,
		"LICENSE":                     2,
		"ERROR_RESPONSE":              3,
		"SERVICE_CERTIFICATE_REQUEST": 4,
		"SERVICE_CERTIFICATE":         5,
	}
)

func (x SignedLicense_MessageType) Enum() *SignedLicense_MessageType {
	p := new(SignedLicense_MessageType)
	*p = x
	return p
}

func (x SignedLicense_MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SignedLicense_MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_drm_widevine_cdm_widevine_proto_enumTypes[12].Descriptor()
}

func (SignedLicense_MessageType) Type() protoreflect.EnumType {
	return &file_drm_widevine_cdm_widevine_proto_enumTypes[12]
}

func (x SignedLicense_MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *SignedLicense_MessageType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = SignedLicense_MessageType(num)
	return nil
}

// Deprecated: Use SignedLicense_MessageType.Descriptor instead.
func (SignedLicense_MessageType) EnumDescriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{9, 0}
}

// Original Widevine CENC Header copied from:
//   - Widevine: Common Encryption API for Widevine DRM (Version 1.5)
//     URL: https://storage.googleapis.com/wvdocs/Widevine_DRM_Encryption_API.pdf
type WidevineCencHeader struct {
	state     protoimpl.MessageState        `protogen:"open.v1"`
	Algorithm *WidevineCencHeader_Algorithm `protobuf:"varint,1,opt,name=algorithm,enum=WidevineCencHeader_Algorithm" json:"algorithm,omitempty"`
	KeyId     [][]byte                      `protobuf:"bytes,2,rep,name=key_id,json=keyId" json:"key_id,omitempty"`
	// Content provider name.
	Provider *string `protobuf:"bytes,3,opt,name=provider" json:"provider,omitempty"`
	// A content identifier, specified by content provider.
	ContentId []byte `protobuf:"bytes,4,opt,name=content_id,json=contentId" json:"content_id,omitempty"`
	// Track type. Acceptable values are SD, HD and AUDIO. Used to
	// differentiate content keys used by an asset.
	TrackTypeDeprecated *string `protobuf:"bytes,5,opt,name=track_type_deprecated,json=trackTypeDeprecated" json:"track_type_deprecated,omitempty"`
	// The name of a registered policy to be used for this asset.
	Policy *string `protobuf:"bytes,6,opt,name=policy" json:"policy,omitempty"`
	// Crypto period index, for media using key rotation.
	CryptoPeriodIndex *uint32 `protobuf:"varint,7,opt,name=crypto_period_index,json=cryptoPeriodIndex" json:"crypto_period_index,omitempty"`
	// Optional protected context for group content. The grouped_license is a
	// serialized SignedMessage.
	GroupedLicense []byte `protobuf:"bytes,8,opt,name=grouped_license,json=groupedLicense" json:"grouped_license,omitempty"`
	// Protection scheme identifying the encryption algorithm.
	// Represented as one of the following 4CC values:
	// 'cenc' (AESCTR), 'cbc1' (AESCBC),
	// 'cens' (AESCTR subsample), 'cbcs' (AESCBC subsample).
	ProtectionScheme *uint32 `protobuf:"varint,9,opt,name=protection_scheme,json=protectionScheme" json:"protection_scheme,omitempty"`
	// Optional. For media using key rotation, this represents the duration
	// of each crypto period in seconds.
	CryptoPeriodSeconds *uint32 `protobuf:"varint,10,opt,name=crypto_period_seconds,json=cryptoPeriodSeconds" json:"crypto_period_seconds,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *WidevineCencHeader) Reset() {
	*x = WidevineCencHeader{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WidevineCencHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WidevineCencHeader) ProtoMessage() {}

func (x *WidevineCencHeader) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WidevineCencHeader.ProtoReflect.Descriptor instead.
func (*WidevineCencHeader) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{0}
}

func (x *WidevineCencHeader) GetAlgorithm() WidevineCencHeader_Algorithm {
	if x != nil && x.Algorithm != nil {
		return *x.Algorithm
	}
	return WidevineCencHeader_UNENCRYPTED
}

func (x *WidevineCencHeader) GetKeyId() [][]byte {
	if x != nil {
		return x.KeyId
	}
	return nil
}

func (x *WidevineCencHeader) GetProvider() string {
	if x != nil && x.Provider != nil {
		return *x.Provider
	}
	return ""
}

func (x *WidevineCencHeader) GetContentId() []byte {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *WidevineCencHeader) GetTrackTypeDeprecated() string {
	if x != nil && x.TrackTypeDeprecated != nil {
		return *x.TrackTypeDeprecated
	}
	return ""
}

func (x *WidevineCencHeader) GetPolicy() string {
	if x != nil && x.Policy != nil {
		return *x.Policy
	}
	return ""
}

func (x *WidevineCencHeader) GetCryptoPeriodIndex() uint32 {
	if x != nil && x.CryptoPeriodIndex != nil {
		return *x.CryptoPeriodIndex
	}
	return 0
}

func (x *WidevineCencHeader) GetGroupedLicense() []byte {
	if x != nil {
		return x.GroupedLicense
	}
	return nil
}

func (x *WidevineCencHeader) GetProtectionScheme() uint32 {
	if x != nil && x.ProtectionScheme != nil {
		return *x.ProtectionScheme
	}
	return 0
}

func (x *WidevineCencHeader) GetCryptoPeriodSeconds() uint32 {
	if x != nil && x.CryptoPeriodSeconds != nil {
		return *x.CryptoPeriodSeconds
	}
	return 0
}

// LicenseIdentification is propagated from LicenseRequest to License,
// incrementing version with each iteration.
type LicenseIdentification struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	RequestId            []byte                 `protobuf:"bytes,1,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	SessionId            []byte                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	PurchaseId           []byte                 `protobuf:"bytes,3,opt,name=purchase_id,json=purchaseId" json:"purchase_id,omitempty"`
	Type                 *LicenseType           `protobuf:"varint,4,opt,name=type,enum=LicenseType" json:"type,omitempty"`
	Version              *int32                 `protobuf:"varint,5,opt,name=version" json:"version,omitempty"`
	ProviderSessionToken []byte                 `protobuf:"bytes,6,opt,name=provider_session_token,json=providerSessionToken" json:"provider_session_token,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *LicenseIdentification) Reset() {
	*x = LicenseIdentification{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseIdentification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseIdentification) ProtoMessage() {}

func (x *LicenseIdentification) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseIdentification.ProtoReflect.Descriptor instead.
func (*LicenseIdentification) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{1}
}

func (x *LicenseIdentification) GetRequestId() []byte {
	if x != nil {
		return x.RequestId
	}
	return nil
}

func (x *LicenseIdentification) GetSessionId() []byte {
	if x != nil {
		return x.SessionId
	}
	return nil
}

func (x *LicenseIdentification) GetPurchaseId() []byte {
	if x != nil {
		return x.PurchaseId
	}
	return nil
}

func (x *LicenseIdentification) GetType() LicenseType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return LicenseType_STREAMING
}

func (x *LicenseIdentification) GetVersion() int32 {
	if x != nil && x.Version != nil {
		return *x.Version
	}
	return 0
}

func (x *LicenseIdentification) GetProviderSessionToken() []byte {
	if x != nil {
		return x.ProviderSessionToken
	}
	return nil
}

type License struct {
	state                     protoimpl.MessageState  `protogen:"open.v1"`
	Id                        *LicenseIdentification  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Policy                    *License_Policy         `protobuf:"bytes,2,opt,name=policy" json:"policy,omitempty"`
	Key                       []*License_KeyContainer `protobuf:"bytes,3,rep,name=key" json:"key,omitempty"`
	LicenseStartTime          *int64                  `protobuf:"varint,4,opt,name=license_start_time,json=licenseStartTime" json:"license_start_time,omitempty"`
	RemoteAttestationVerified *bool                   `protobuf:"varint,5,opt,name=remote_attestation_verified,json=remoteAttestationVerified,def=0" json:"remote_attestation_verified,omitempty"`
	// Client token generated by the content provider. Optional.
	ProviderClientToken []byte `protobuf:"bytes,6,opt,name=provider_client_token,json=providerClientToken" json:"provider_client_token,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

// Default values for License fields.
const (
	Default_License_RemoteAttestationVerified = bool(false)
)

func (x *License) Reset() {
	*x = License{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License) ProtoMessage() {}

func (x *License) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License.ProtoReflect.Descriptor instead.
func (*License) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2}
}

func (x *License) GetId() *LicenseIdentification {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *License) GetPolicy() *License_Policy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *License) GetKey() []*License_KeyContainer {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *License) GetLicenseStartTime() int64 {
	if x != nil && x.LicenseStartTime != nil {
		return *x.LicenseStartTime
	}
	return 0
}

func (x *License) GetRemoteAttestationVerified() bool {
	if x != nil && x.RemoteAttestationVerified != nil {
		return *x.RemoteAttestationVerified
	}
	return Default_License_RemoteAttestationVerified
}

func (x *License) GetProviderClientToken() []byte {
	if x != nil {
		return x.ProviderClientToken
	}
	return nil
}

type LicenseRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The client_id provides information authenticating the calling device.  It
	// contains the Widevine keybox token that was installed on the device at the
	// factory.  This field or encrypted_client_id below is required for a valid
	// license request, but both should never be present in the same request.
	ClientId    *ClientIdentification                 `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	ContentId   *LicenseRequest_ContentIdentification `protobuf:"bytes,2,opt,name=content_id,json=contentId" json:"content_id,omitempty"`
	Type        *LicenseRequest_RequestType           `protobuf:"varint,3,opt,name=type,enum=LicenseRequest_RequestType" json:"type,omitempty"`
	RequestTime *int64                                `protobuf:"varint,4,opt,name=request_time,json=requestTime" json:"request_time,omitempty"`
	// Old-style decimal-encoded string key control nonce.
	KeyControlNonceDeprecated []byte           `protobuf:"bytes,5,opt,name=key_control_nonce_deprecated,json=keyControlNonceDeprecated" json:"key_control_nonce_deprecated,omitempty"`
	ProtocolVersion           *ProtocolVersion `protobuf:"varint,6,opt,name=protocol_version,json=protocolVersion,enum=ProtocolVersion,def=20" json:"protocol_version,omitempty"`
	// New-style uint32 key control nonce, please use instead of
	// key_control_nonce_deprecated.
	KeyControlNonce *uint32 `protobuf:"varint,7,opt,name=key_control_nonce,json=keyControlNonce" json:"key_control_nonce,omitempty"`
	// Encrypted ClientIdentification message, used for privacy purposes.
	EncryptedClientId *EncryptedClientIdentification `protobuf:"bytes,8,opt,name=encrypted_client_id,json=encryptedClientId" json:"encrypted_client_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

// Default values for LicenseRequest fields.
const (
	Default_LicenseRequest_ProtocolVersion = ProtocolVersion_VERSION_2_0
)

func (x *LicenseRequest) Reset() {
	*x = LicenseRequest{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest) ProtoMessage() {}

func (x *LicenseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest.ProtoReflect.Descriptor instead.
func (*LicenseRequest) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3}
}

func (x *LicenseRequest) GetClientId() *ClientIdentification {
	if x != nil {
		return x.ClientId
	}
	return nil
}

func (x *LicenseRequest) GetContentId() *LicenseRequest_ContentIdentification {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *LicenseRequest) GetType() LicenseRequest_RequestType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return LicenseRequest_NEW
}

func (x *LicenseRequest) GetRequestTime() int64 {
	if x != nil && x.RequestTime != nil {
		return *x.RequestTime
	}
	return 0
}

func (x *LicenseRequest) GetKeyControlNonceDeprecated() []byte {
	if x != nil {
		return x.KeyControlNonceDeprecated
	}
	return nil
}

func (x *LicenseRequest) GetProtocolVersion() ProtocolVersion {
	if x != nil && x.ProtocolVersion != nil {
		return *x.ProtocolVersion
	}
	return Default_LicenseRequest_ProtocolVersion
}

func (x *LicenseRequest) GetKeyControlNonce() uint32 {
	if x != nil && x.KeyControlNonce != nil {
		return *x.KeyControlNonce
	}
	return 0
}

func (x *LicenseRequest) GetEncryptedClientId() *EncryptedClientIdentification {
	if x != nil {
		return x.EncryptedClientId
	}
	return nil
}

type RemoteAttestation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Encrypted ClientIdentification message containing the device remote
	// attestation certificate. Required.
	Certificate *EncryptedClientIdentification `protobuf:"bytes,1,opt,name=certificate" json:"certificate,omitempty"`
	// Bytes of salt which were added to the remote attestation challenge prior to
	// signing it. Required.
	Salt []byte `protobuf:"bytes,2,opt,name=salt" json:"salt,omitempty"`
	// Signed remote attestation challenge + salt. Required.
	Signature     []byte `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteAttestation) Reset() {
	*x = RemoteAttestation{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteAttestation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteAttestation) ProtoMessage() {}

func (x *RemoteAttestation) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteAttestation.ProtoReflect.Descriptor instead.
func (*RemoteAttestation) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{4}
}

func (x *RemoteAttestation) GetCertificate() *EncryptedClientIdentification {
	if x != nil {
		return x.Certificate
	}
	return nil
}

func (x *RemoteAttestation) GetSalt() []byte {
	if x != nil {
		return x.Salt
	}
	return nil
}

func (x *RemoteAttestation) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type SignedMessage struct {
	state      protoimpl.MessageState     `protogen:"open.v1"`
	Type       *SignedMessage_MessageType `protobuf:"varint,1,opt,name=type,enum=SignedMessage_MessageType" json:"type,omitempty"`
	Msg        [][]byte                   `protobuf:"bytes,2,rep,name=msg" json:"msg,omitempty"`
	Signature  []byte                     `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	SessionKey []byte                     `protobuf:"bytes,4,opt,name=session_key,json=sessionKey" json:"session_key,omitempty"`
	// Remote attestation data which will be present in the initial license
	// request for ChromeOS client devices operating in verified mode. Remote
	// attestation challenge data is |msg| field above. Optional.
	RemoteAttestation *RemoteAttestation `protobuf:"bytes,5,opt,name=remote_attestation,json=remoteAttestation" json:"remote_attestation,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SignedMessage) Reset() {
	*x = SignedMessage{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedMessage) ProtoMessage() {}

func (x *SignedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedMessage.ProtoReflect.Descriptor instead.
func (*SignedMessage) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{5}
}

func (x *SignedMessage) GetType() SignedMessage_MessageType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return SignedMessage_LICENSE_REQUEST
}

func (x *SignedMessage) GetMsg() [][]byte {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *SignedMessage) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignedMessage) GetSessionKey() []byte {
	if x != nil {
		return x.SessionKey
	}
	return nil
}

func (x *SignedMessage) GetRemoteAttestation() *RemoteAttestation {
	if x != nil {
		return x.RemoteAttestation
	}
	return nil
}

// ClientIdentification message used to authenticate the client device.
type ClientIdentification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of factory-provisioned device root of trust. Optional.
	Type *ClientIdentification_TokenType `protobuf:"varint,1,opt,name=type,enum=ClientIdentification_TokenType,def=0" json:"type,omitempty"`
	// Factory-provisioned device root of trust. Required.
	Token []byte `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	// Optional client information name/value pairs.
	ClientInfo []*ClientIdentification_NameValue `protobuf:"bytes,3,rep,name=client_info,json=clientInfo" json:"client_info,omitempty"`
	// Client token generated by the content provider. Optional.
	ProviderClientToken []byte `protobuf:"bytes,4,opt,name=provider_client_token,json=providerClientToken" json:"provider_client_token,omitempty"`
	// Number of licenses received by the client to which the token above belongs.
	// Only present if client_token is specified.
	LicenseCounter *uint32 `protobuf:"varint,5,opt,name=license_counter,json=licenseCounter" json:"license_counter,omitempty"`
	// List of non-baseline client capabilities.
	ClientCapabilities *ClientIdentification_ClientCapabilities `protobuf:"bytes,6,opt,name=client_capabilities,json=clientCapabilities" json:"client_capabilities,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

// Default values for ClientIdentification fields.
const (
	Default_ClientIdentification_Type = ClientIdentification_KEYBOX
)

func (x *ClientIdentification) Reset() {
	*x = ClientIdentification{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientIdentification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientIdentification) ProtoMessage() {}

func (x *ClientIdentification) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientIdentification.ProtoReflect.Descriptor instead.
func (*ClientIdentification) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{6}
}

func (x *ClientIdentification) GetType() ClientIdentification_TokenType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Default_ClientIdentification_Type
}

func (x *ClientIdentification) GetToken() []byte {
	if x != nil {
		return x.Token
	}
	return nil
}

func (x *ClientIdentification) GetClientInfo() []*ClientIdentification_NameValue {
	if x != nil {
		return x.ClientInfo
	}
	return nil
}

func (x *ClientIdentification) GetProviderClientToken() []byte {
	if x != nil {
		return x.ProviderClientToken
	}
	return nil
}

func (x *ClientIdentification) GetLicenseCounter() uint32 {
	if x != nil && x.LicenseCounter != nil {
		return *x.LicenseCounter
	}
	return 0
}

func (x *ClientIdentification) GetClientCapabilities() *ClientIdentification_ClientCapabilities {
	if x != nil {
		return x.ClientCapabilities
	}
	return nil
}

// EncryptedClientIdentification message used to hold ClientIdentification
// messages encrypted for privacy purposes.
type EncryptedClientIdentification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Service ID for which the ClientIdentifcation is encrypted (owner of service
	// certificate).
	ServiceId *string `protobuf:"bytes,1,opt,name=service_id,json=serviceId" json:"service_id,omitempty"`
	// Serial number for the service certificate for which ClientIdentification is
	// encrypted.
	ServiceCertificateSerialNumber []byte `protobuf:"bytes,2,opt,name=service_certificate_serial_number,json=serviceCertificateSerialNumber" json:"service_certificate_serial_number,omitempty"`
	// Serialized ClientIdentification message, encrypted with the privacy key using
	// AES-128-CBC with PKCS#5 padding.
	EncryptedClientId []byte `protobuf:"bytes,3,opt,name=encrypted_client_id,json=encryptedClientId" json:"encrypted_client_id,omitempty"`
	// Initialization vector needed to decrypt encrypted_client_id.
	EncryptedClientIdIv []byte `protobuf:"bytes,4,opt,name=encrypted_client_id_iv,json=encryptedClientIdIv" json:"encrypted_client_id_iv,omitempty"`
	// AES-128 privacy key, encrytped with the service public public key using
	// RSA-OAEP.
	EncryptedPrivacyKey []byte `protobuf:"bytes,5,opt,name=encrypted_privacy_key,json=encryptedPrivacyKey" json:"encrypted_privacy_key,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *EncryptedClientIdentification) Reset() {
	*x = EncryptedClientIdentification{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EncryptedClientIdentification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptedClientIdentification) ProtoMessage() {}

func (x *EncryptedClientIdentification) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EncryptedClientIdentification.ProtoReflect.Descriptor instead.
func (*EncryptedClientIdentification) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{7}
}

func (x *EncryptedClientIdentification) GetServiceId() string {
	if x != nil && x.ServiceId != nil {
		return *x.ServiceId
	}
	return ""
}

func (x *EncryptedClientIdentification) GetServiceCertificateSerialNumber() []byte {
	if x != nil {
		return x.ServiceCertificateSerialNumber
	}
	return nil
}

func (x *EncryptedClientIdentification) GetEncryptedClientId() []byte {
	if x != nil {
		return x.EncryptedClientId
	}
	return nil
}

func (x *EncryptedClientIdentification) GetEncryptedClientIdIv() []byte {
	if x != nil {
		return x.EncryptedClientIdIv
	}
	return nil
}

func (x *EncryptedClientIdentification) GetEncryptedPrivacyKey() []byte {
	if x != nil {
		return x.EncryptedPrivacyKey
	}
	return nil
}

type SignedLicenseRequest struct {
	state      protoimpl.MessageState            `protogen:"open.v1"`
	Type       *SignedLicenseRequest_MessageType `protobuf:"varint,1,opt,name=type,enum=SignedLicenseRequest_MessageType" json:"type,omitempty"`
	Msg        *LicenseRequest                   `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	Signature  []byte                            `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	SessionKey []byte                            `protobuf:"bytes,4,opt,name=session_key,json=sessionKey" json:"session_key,omitempty"`
	// Remote attestation data which will be present in the initial license
	// request for ChromeOS client devices operating in verified mode. Remote
	// attestation challenge data is |msg| field above. Optional.
	RemoteAttestation *RemoteAttestation `protobuf:"bytes,5,opt,name=remote_attestation,json=remoteAttestation" json:"remote_attestation,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SignedLicenseRequest) Reset() {
	*x = SignedLicenseRequest{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedLicenseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedLicenseRequest) ProtoMessage() {}

func (x *SignedLicenseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedLicenseRequest.ProtoReflect.Descriptor instead.
func (*SignedLicenseRequest) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{8}
}

func (x *SignedLicenseRequest) GetType() SignedLicenseRequest_MessageType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return SignedLicenseRequest_LICENSE_REQUEST
}

func (x *SignedLicenseRequest) GetMsg() *LicenseRequest {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *SignedLicenseRequest) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignedLicenseRequest) GetSessionKey() []byte {
	if x != nil {
		return x.SessionKey
	}
	return nil
}

func (x *SignedLicenseRequest) GetRemoteAttestation() *RemoteAttestation {
	if x != nil {
		return x.RemoteAttestation
	}
	return nil
}

type SignedLicense struct {
	state      protoimpl.MessageState     `protogen:"open.v1"`
	Type       *SignedLicense_MessageType `protobuf:"varint,1,opt,name=type,enum=SignedLicense_MessageType" json:"type,omitempty"`
	Msg        *License                   `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	Signature  []byte                     `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	SessionKey []byte                     `protobuf:"bytes,4,opt,name=session_key,json=sessionKey" json:"session_key,omitempty"`
	// Remote attestation data which will be present in the initial license
	// request for ChromeOS client devices operating in verified mode. Remote
	// attestation challenge data is |msg| field above. Optional.
	RemoteAttestation *RemoteAttestation `protobuf:"bytes,5,opt,name=remote_attestation,json=remoteAttestation" json:"remote_attestation,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SignedLicense) Reset() {
	*x = SignedLicense{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedLicense) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedLicense) ProtoMessage() {}

func (x *SignedLicense) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedLicense.ProtoReflect.Descriptor instead.
func (*SignedLicense) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{9}
}

func (x *SignedLicense) GetType() SignedLicense_MessageType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return SignedLicense_LICENSE_REQUEST
}

func (x *SignedLicense) GetMsg() *License {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *SignedLicense) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SignedLicense) GetSessionKey() []byte {
	if x != nil {
		return x.SessionKey
	}
	return nil
}

func (x *SignedLicense) GetRemoteAttestation() *RemoteAttestation {
	if x != nil {
		return x.RemoteAttestation
	}
	return nil
}

type License_Policy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicates that playback of the content is allowed.
	CanPlay *bool `protobuf:"varint,1,opt,name=can_play,json=canPlay,def=0" json:"can_play,omitempty"`
	// Indicates that the license may be persisted to non-volatile
	// storage for offline use.
	CanPersist *bool `protobuf:"varint,2,opt,name=can_persist,json=canPersist,def=0" json:"can_persist,omitempty"`
	// Indicates that renewal of this license is allowed.
	CanRenew *bool `protobuf:"varint,3,opt,name=can_renew,json=canRenew,def=0" json:"can_renew,omitempty"`
	// Indicates the rental window.
	RentalDurationSeconds *int64 `protobuf:"varint,4,opt,name=rental_duration_seconds,json=rentalDurationSeconds,def=0" json:"rental_duration_seconds,omitempty"`
	// Indicates the viewing window, once playback has begun.
	PlaybackDurationSeconds *int64 `protobuf:"varint,5,opt,name=playback_duration_seconds,json=playbackDurationSeconds,def=0" json:"playback_duration_seconds,omitempty"`
	// Indicates the time window for this specific license.
	LicenseDurationSeconds *int64 `protobuf:"varint,6,opt,name=license_duration_seconds,json=licenseDurationSeconds,def=0" json:"license_duration_seconds,omitempty"`
	// The window of time, in which playback is allowed to continue while
	// renewal is attempted, yet unsuccessful due to backend problems with
	// the license server.
	RenewalRecoveryDurationSeconds *int64 `protobuf:"varint,7,opt,name=renewal_recovery_duration_seconds,json=renewalRecoveryDurationSeconds,def=0" json:"renewal_recovery_duration_seconds,omitempty"`
	// All renewal requests for this license shall be directed to the
	// specified URL.
	RenewalServerUrl *string `protobuf:"bytes,8,opt,name=renewal_server_url,json=renewalServerUrl" json:"renewal_server_url,omitempty"`
	// How many seconds after license_start_time, before renewal is first
	// attempted.
	RenewalDelaySeconds *int64 `protobuf:"varint,9,opt,name=renewal_delay_seconds,json=renewalDelaySeconds,def=0" json:"renewal_delay_seconds,omitempty"`
	// Specifies the delay in seconds between subsequent license
	// renewal requests, in case of failure.
	RenewalRetryIntervalSeconds *int64 `protobuf:"varint,10,opt,name=renewal_retry_interval_seconds,json=renewalRetryIntervalSeconds,def=0" json:"renewal_retry_interval_seconds,omitempty"`
	// Indicates that the license shall be sent for renewal when usage is
	// started.
	RenewWithUsage *bool `protobuf:"varint,11,opt,name=renew_with_usage,json=renewWithUsage,def=0" json:"renew_with_usage,omitempty"`
	// Indicates to client that license renewal and release requests ought to
	// include ClientIdentification (client_id).
	RenewWithClientId *bool `protobuf:"varint,12,opt,name=renew_with_client_id,json=renewWithClientId,def=0" json:"renew_with_client_id,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

// Default values for License_Policy fields.
const (
	Default_License_Policy_CanPlay                        = bool(false)
	Default_License_Policy_CanPersist                     = bool(false)
	Default_License_Policy_CanRenew                       = bool(false)
	Default_License_Policy_RentalDurationSeconds          = int64(0)
	Default_License_Policy_PlaybackDurationSeconds        = int64(0)
	Default_License_Policy_LicenseDurationSeconds         = int64(0)
	Default_License_Policy_RenewalRecoveryDurationSeconds = int64(0)
	Default_License_Policy_RenewalDelaySeconds            = int64(0)
	Default_License_Policy_RenewalRetryIntervalSeconds    = int64(0)
	Default_License_Policy_RenewWithUsage                 = bool(false)
	Default_License_Policy_RenewWithClientId              = bool(false)
)

func (x *License_Policy) Reset() {
	*x = License_Policy{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_Policy) ProtoMessage() {}

func (x *License_Policy) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_Policy.ProtoReflect.Descriptor instead.
func (*License_Policy) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 0}
}

func (x *License_Policy) GetCanPlay() bool {
	if x != nil && x.CanPlay != nil {
		return *x.CanPlay
	}
	return Default_License_Policy_CanPlay
}

func (x *License_Policy) GetCanPersist() bool {
	if x != nil && x.CanPersist != nil {
		return *x.CanPersist
	}
	return Default_License_Policy_CanPersist
}

func (x *License_Policy) GetCanRenew() bool {
	if x != nil && x.CanRenew != nil {
		return *x.CanRenew
	}
	return Default_License_Policy_CanRenew
}

func (x *License_Policy) GetRentalDurationSeconds() int64 {
	if x != nil && x.RentalDurationSeconds != nil {
		return *x.RentalDurationSeconds
	}
	return Default_License_Policy_RentalDurationSeconds
}

func (x *License_Policy) GetPlaybackDurationSeconds() int64 {
	if x != nil && x.PlaybackDurationSeconds != nil {
		return *x.PlaybackDurationSeconds
	}
	return Default_License_Policy_PlaybackDurationSeconds
}

func (x *License_Policy) GetLicenseDurationSeconds() int64 {
	if x != nil && x.LicenseDurationSeconds != nil {
		return *x.LicenseDurationSeconds
	}
	return Default_License_Policy_LicenseDurationSeconds
}

func (x *License_Policy) GetRenewalRecoveryDurationSeconds() int64 {
	if x != nil && x.RenewalRecoveryDurationSeconds != nil {
		return *x.RenewalRecoveryDurationSeconds
	}
	return Default_License_Policy_RenewalRecoveryDurationSeconds
}

func (x *License_Policy) GetRenewalServerUrl() string {
	if x != nil && x.RenewalServerUrl != nil {
		return *x.RenewalServerUrl
	}
	return ""
}

func (x *License_Policy) GetRenewalDelaySeconds() int64 {
	if x != nil && x.RenewalDelaySeconds != nil {
		return *x.RenewalDelaySeconds
	}
	return Default_License_Policy_RenewalDelaySeconds
}

func (x *License_Policy) GetRenewalRetryIntervalSeconds() int64 {
	if x != nil && x.RenewalRetryIntervalSeconds != nil {
		return *x.RenewalRetryIntervalSeconds
	}
	return Default_License_Policy_RenewalRetryIntervalSeconds
}

func (x *License_Policy) GetRenewWithUsage() bool {
	if x != nil && x.RenewWithUsage != nil {
		return *x.RenewWithUsage
	}
	return Default_License_Policy_RenewWithUsage
}

func (x *License_Policy) GetRenewWithClientId() bool {
	if x != nil && x.RenewWithClientId != nil {
		return *x.RenewWithClientId
	}
	return Default_License_Policy_RenewWithClientId
}

type License_KeyContainer struct {
	state              protoimpl.MessageState                 `protogen:"open.v1"`
	Id                 []byte                                 `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Iv                 []byte                                 `protobuf:"bytes,2,opt,name=iv" json:"iv,omitempty"`
	Key                []byte                                 `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	Type               *License_KeyContainer_KeyType          `protobuf:"varint,4,opt,name=type,enum=License_KeyContainer_KeyType" json:"type,omitempty"`
	Level              *License_KeyContainer_SecurityLevel    `protobuf:"varint,5,opt,name=level,enum=License_KeyContainer_SecurityLevel,def=1" json:"level,omitempty"`
	RequiredProtection *License_KeyContainer_OutputProtection `protobuf:"bytes,6,opt,name=required_protection,json=requiredProtection" json:"required_protection,omitempty"`
	// NOTE: Use of requested_protection is not recommended as it is only
	// supported on a small number of platforms.
	RequestedProtection           *License_KeyContainer_OutputProtection              `protobuf:"bytes,7,opt,name=requested_protection,json=requestedProtection" json:"requested_protection,omitempty"`
	KeyControl                    *License_KeyContainer_KeyControl                    `protobuf:"bytes,8,opt,name=key_control,json=keyControl" json:"key_control,omitempty"`
	OperatorSessionKeyPermissions *License_KeyContainer_OperatorSessionKeyPermissions `protobuf:"bytes,9,opt,name=operator_session_key_permissions,json=operatorSessionKeyPermissions" json:"operator_session_key_permissions,omitempty"`
	// Optional video resolution constraints. If the video resolution of the
	// content being decrypted/decoded falls within one of the specified ranges,
	// the optional required_protections may be applied. Otherwise an error will
	// be reported.
	// NOTE: Use of this feature is not recommended, as it is only supported on
	// a small number of platforms.
	VideoResolutionConstraints []*License_KeyContainer_VideoResolutionConstraint `protobuf:"bytes,10,rep,name=video_resolution_constraints,json=videoResolutionConstraints" json:"video_resolution_constraints,omitempty"`
	// Optional flag to indicate the key must only be used if the client
	// supports anti rollback of the user table.  Content provider can query the
	// client capabilities to determine if the client support this feature.
	AntiRollbackUsageTable *bool `protobuf:"varint,11,opt,name=anti_rollback_usage_table,json=antiRollbackUsageTable,def=0" json:"anti_rollback_usage_table,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

// Default values for License_KeyContainer fields.
const (
	Default_License_KeyContainer_Level                  = License_KeyContainer_SW_SECURE_CRYPTO
	Default_License_KeyContainer_AntiRollbackUsageTable = bool(false)
)

func (x *License_KeyContainer) Reset() {
	*x = License_KeyContainer{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_KeyContainer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_KeyContainer) ProtoMessage() {}

func (x *License_KeyContainer) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_KeyContainer.ProtoReflect.Descriptor instead.
func (*License_KeyContainer) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1}
}

func (x *License_KeyContainer) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *License_KeyContainer) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

func (x *License_KeyContainer) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *License_KeyContainer) GetType() License_KeyContainer_KeyType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return License_KeyContainer_SIGNING
}

func (x *License_KeyContainer) GetLevel() License_KeyContainer_SecurityLevel {
	if x != nil && x.Level != nil {
		return *x.Level
	}
	return Default_License_KeyContainer_Level
}

func (x *License_KeyContainer) GetRequiredProtection() *License_KeyContainer_OutputProtection {
	if x != nil {
		return x.RequiredProtection
	}
	return nil
}

func (x *License_KeyContainer) GetRequestedProtection() *License_KeyContainer_OutputProtection {
	if x != nil {
		return x.RequestedProtection
	}
	return nil
}

func (x *License_KeyContainer) GetKeyControl() *License_KeyContainer_KeyControl {
	if x != nil {
		return x.KeyControl
	}
	return nil
}

func (x *License_KeyContainer) GetOperatorSessionKeyPermissions() *License_KeyContainer_OperatorSessionKeyPermissions {
	if x != nil {
		return x.OperatorSessionKeyPermissions
	}
	return nil
}

func (x *License_KeyContainer) GetVideoResolutionConstraints() []*License_KeyContainer_VideoResolutionConstraint {
	if x != nil {
		return x.VideoResolutionConstraints
	}
	return nil
}

func (x *License_KeyContainer) GetAntiRollbackUsageTable() bool {
	if x != nil && x.AntiRollbackUsageTable != nil {
		return *x.AntiRollbackUsageTable
	}
	return Default_License_KeyContainer_AntiRollbackUsageTable
}

type License_KeyContainer_KeyControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If present, the key control must be communicated to the secure
	// environment prior to any usage. This message is automatically generated
	// by the Widevine License Server SDK.
	KeyControlBlock []byte `protobuf:"bytes,1,opt,name=key_control_block,json=keyControlBlock" json:"key_control_block,omitempty"`
	Iv              []byte `protobuf:"bytes,2,opt,name=iv" json:"iv,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *License_KeyContainer_KeyControl) Reset() {
	*x = License_KeyContainer_KeyControl{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_KeyContainer_KeyControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_KeyContainer_KeyControl) ProtoMessage() {}

func (x *License_KeyContainer_KeyControl) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_KeyContainer_KeyControl.ProtoReflect.Descriptor instead.
func (*License_KeyContainer_KeyControl) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 0}
}

func (x *License_KeyContainer_KeyControl) GetKeyControlBlock() []byte {
	if x != nil {
		return x.KeyControlBlock
	}
	return nil
}

func (x *License_KeyContainer_KeyControl) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

type License_KeyContainer_OutputProtection struct {
	state         protoimpl.MessageState                      `protogen:"open.v1"`
	Hdcp          *License_KeyContainer_OutputProtection_HDCP `protobuf:"varint,1,opt,name=hdcp,enum=License_KeyContainer_OutputProtection_HDCP,def=0" json:"hdcp,omitempty"`
	CgmsFlags     *License_KeyContainer_OutputProtection_CGMS `protobuf:"varint,2,opt,name=cgms_flags,json=cgmsFlags,enum=License_KeyContainer_OutputProtection_CGMS,def=42" json:"cgms_flags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for License_KeyContainer_OutputProtection fields.
const (
	Default_License_KeyContainer_OutputProtection_Hdcp      = License_KeyContainer_OutputProtection_HDCP_NONE
	Default_License_KeyContainer_OutputProtection_CgmsFlags = License_KeyContainer_OutputProtection_CGMS_NONE
)

func (x *License_KeyContainer_OutputProtection) Reset() {
	*x = License_KeyContainer_OutputProtection{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_KeyContainer_OutputProtection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_KeyContainer_OutputProtection) ProtoMessage() {}

func (x *License_KeyContainer_OutputProtection) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_KeyContainer_OutputProtection.ProtoReflect.Descriptor instead.
func (*License_KeyContainer_OutputProtection) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 1}
}

func (x *License_KeyContainer_OutputProtection) GetHdcp() License_KeyContainer_OutputProtection_HDCP {
	if x != nil && x.Hdcp != nil {
		return *x.Hdcp
	}
	return Default_License_KeyContainer_OutputProtection_Hdcp
}

func (x *License_KeyContainer_OutputProtection) GetCgmsFlags() License_KeyContainer_OutputProtection_CGMS {
	if x != nil && x.CgmsFlags != nil {
		return *x.CgmsFlags
	}
	return Default_License_KeyContainer_OutputProtection_CgmsFlags
}

type License_KeyContainer_VideoResolutionConstraint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum and maximum video resolutions in the range (height x width).
	MinResolutionPixels *uint32 `protobuf:"varint,1,opt,name=min_resolution_pixels,json=minResolutionPixels" json:"min_resolution_pixels,omitempty"`
	MaxResolutionPixels *uint32 `protobuf:"varint,2,opt,name=max_resolution_pixels,json=maxResolutionPixels" json:"max_resolution_pixels,omitempty"`
	// Optional output protection requirements for this range. If not
	// specified, the OutputProtection in the KeyContainer applies.
	RequiredProtection *License_KeyContainer_OutputProtection `protobuf:"bytes,3,opt,name=required_protection,json=requiredProtection" json:"required_protection,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *License_KeyContainer_VideoResolutionConstraint) Reset() {
	*x = License_KeyContainer_VideoResolutionConstraint{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_KeyContainer_VideoResolutionConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_KeyContainer_VideoResolutionConstraint) ProtoMessage() {}

func (x *License_KeyContainer_VideoResolutionConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_KeyContainer_VideoResolutionConstraint.ProtoReflect.Descriptor instead.
func (*License_KeyContainer_VideoResolutionConstraint) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 2}
}

func (x *License_KeyContainer_VideoResolutionConstraint) GetMinResolutionPixels() uint32 {
	if x != nil && x.MinResolutionPixels != nil {
		return *x.MinResolutionPixels
	}
	return 0
}

func (x *License_KeyContainer_VideoResolutionConstraint) GetMaxResolutionPixels() uint32 {
	if x != nil && x.MaxResolutionPixels != nil {
		return *x.MaxResolutionPixels
	}
	return 0
}

func (x *License_KeyContainer_VideoResolutionConstraint) GetRequiredProtection() *License_KeyContainer_OutputProtection {
	if x != nil {
		return x.RequiredProtection
	}
	return nil
}

type License_KeyContainer_OperatorSessionKeyPermissions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Permissions/key usage flags for operator service keys
	// (type = OPERATOR_SESSION).
	AllowEncrypt         *bool `protobuf:"varint,1,opt,name=allow_encrypt,json=allowEncrypt,def=0" json:"allow_encrypt,omitempty"`
	AllowDecrypt         *bool `protobuf:"varint,2,opt,name=allow_decrypt,json=allowDecrypt,def=0" json:"allow_decrypt,omitempty"`
	AllowSign            *bool `protobuf:"varint,3,opt,name=allow_sign,json=allowSign,def=0" json:"allow_sign,omitempty"`
	AllowSignatureVerify *bool `protobuf:"varint,4,opt,name=allow_signature_verify,json=allowSignatureVerify,def=0" json:"allow_signature_verify,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

// Default values for License_KeyContainer_OperatorSessionKeyPermissions fields.
const (
	Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowEncrypt         = bool(false)
	Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowDecrypt         = bool(false)
	Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowSign            = bool(false)
	Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowSignatureVerify = bool(false)
)

func (x *License_KeyContainer_OperatorSessionKeyPermissions) Reset() {
	*x = License_KeyContainer_OperatorSessionKeyPermissions{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*License_KeyContainer_OperatorSessionKeyPermissions) ProtoMessage() {}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use License_KeyContainer_OperatorSessionKeyPermissions.ProtoReflect.Descriptor instead.
func (*License_KeyContainer_OperatorSessionKeyPermissions) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{2, 1, 3}
}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) GetAllowEncrypt() bool {
	if x != nil && x.AllowEncrypt != nil {
		return *x.AllowEncrypt
	}
	return Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowEncrypt
}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) GetAllowDecrypt() bool {
	if x != nil && x.AllowDecrypt != nil {
		return *x.AllowDecrypt
	}
	return Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowDecrypt
}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) GetAllowSign() bool {
	if x != nil && x.AllowSign != nil {
		return *x.AllowSign
	}
	return Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowSign
}

func (x *License_KeyContainer_OperatorSessionKeyPermissions) GetAllowSignatureVerify() bool {
	if x != nil && x.AllowSignatureVerify != nil {
		return *x.AllowSignatureVerify
	}
	return Default_License_KeyContainer_OperatorSessionKeyPermissions_AllowSignatureVerify
}

type LicenseRequest_ContentIdentification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Exactly one of these must be present.
	CencId        *LicenseRequest_ContentIdentification_CENC            `protobuf:"bytes,1,opt,name=cenc_id,json=cencId" json:"cenc_id,omitempty"`
	WebmId        *LicenseRequest_ContentIdentification_WebM            `protobuf:"bytes,2,opt,name=webm_id,json=webmId" json:"webm_id,omitempty"`
	License       *LicenseRequest_ContentIdentification_ExistingLicense `protobuf:"bytes,3,opt,name=license" json:"license,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseRequest_ContentIdentification) Reset() {
	*x = LicenseRequest_ContentIdentification{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest_ContentIdentification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest_ContentIdentification) ProtoMessage() {}

func (x *LicenseRequest_ContentIdentification) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest_ContentIdentification.ProtoReflect.Descriptor instead.
func (*LicenseRequest_ContentIdentification) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3, 0}
}

func (x *LicenseRequest_ContentIdentification) GetCencId() *LicenseRequest_ContentIdentification_CENC {
	if x != nil {
		return x.CencId
	}
	return nil
}

func (x *LicenseRequest_ContentIdentification) GetWebmId() *LicenseRequest_ContentIdentification_WebM {
	if x != nil {
		return x.WebmId
	}
	return nil
}

func (x *LicenseRequest_ContentIdentification) GetLicense() *LicenseRequest_ContentIdentification_ExistingLicense {
	if x != nil {
		return x.License
	}
	return nil
}

type LicenseRequest_ContentIdentification_CENC struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pssh          *WidevineCencHeader    `protobuf:"bytes,1,opt,name=pssh" json:"pssh,omitempty"`
	LicenseType   *LicenseType           `protobuf:"varint,2,opt,name=license_type,json=licenseType,enum=LicenseType" json:"license_type,omitempty"`
	RequestId     []byte                 `protobuf:"bytes,3,opt,name=request_id,json=requestId" json:"request_id,omitempty"` // Opaque, client-specified.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseRequest_ContentIdentification_CENC) Reset() {
	*x = LicenseRequest_ContentIdentification_CENC{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest_ContentIdentification_CENC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest_ContentIdentification_CENC) ProtoMessage() {}

func (x *LicenseRequest_ContentIdentification_CENC) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest_ContentIdentification_CENC.ProtoReflect.Descriptor instead.
func (*LicenseRequest_ContentIdentification_CENC) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3, 0, 0}
}

func (x *LicenseRequest_ContentIdentification_CENC) GetPssh() *WidevineCencHeader {
	if x != nil {
		return x.Pssh
	}
	return nil
}

func (x *LicenseRequest_ContentIdentification_CENC) GetLicenseType() LicenseType {
	if x != nil && x.LicenseType != nil {
		return *x.LicenseType
	}
	return LicenseType_STREAMING
}

func (x *LicenseRequest_ContentIdentification_CENC) GetRequestId() []byte {
	if x != nil {
		return x.RequestId
	}
	return nil
}

type LicenseRequest_ContentIdentification_WebM struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Header        []byte                 `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	LicenseType   *LicenseType           `protobuf:"varint,2,opt,name=license_type,json=licenseType,enum=LicenseType" json:"license_type,omitempty"`
	RequestId     []byte                 `protobuf:"bytes,3,opt,name=request_id,json=requestId" json:"request_id,omitempty"` // Opaque, client-specified.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LicenseRequest_ContentIdentification_WebM) Reset() {
	*x = LicenseRequest_ContentIdentification_WebM{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest_ContentIdentification_WebM) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest_ContentIdentification_WebM) ProtoMessage() {}

func (x *LicenseRequest_ContentIdentification_WebM) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest_ContentIdentification_WebM.ProtoReflect.Descriptor instead.
func (*LicenseRequest_ContentIdentification_WebM) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3, 0, 1}
}

func (x *LicenseRequest_ContentIdentification_WebM) GetHeader() []byte {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *LicenseRequest_ContentIdentification_WebM) GetLicenseType() LicenseType {
	if x != nil && x.LicenseType != nil {
		return *x.LicenseType
	}
	return LicenseType_STREAMING
}

func (x *LicenseRequest_ContentIdentification_WebM) GetRequestId() []byte {
	if x != nil {
		return x.RequestId
	}
	return nil
}

type LicenseRequest_ContentIdentification_ExistingLicense struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	LicenseId              *LicenseIdentification `protobuf:"bytes,1,opt,name=license_id,json=licenseId" json:"license_id,omitempty"`
	SecondsSinceStarted    *int64                 `protobuf:"varint,2,opt,name=seconds_since_started,json=secondsSinceStarted" json:"seconds_since_started,omitempty"`
	SecondsSinceLastPlayed *int64                 `protobuf:"varint,3,opt,name=seconds_since_last_played,json=secondsSinceLastPlayed" json:"seconds_since_last_played,omitempty"`
	SessionUsageTableEntry []byte                 `protobuf:"bytes,4,opt,name=session_usage_table_entry,json=sessionUsageTableEntry" json:"session_usage_table_entry,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) Reset() {
	*x = LicenseRequest_ContentIdentification_ExistingLicense{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LicenseRequest_ContentIdentification_ExistingLicense) ProtoMessage() {}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LicenseRequest_ContentIdentification_ExistingLicense.ProtoReflect.Descriptor instead.
func (*LicenseRequest_ContentIdentification_ExistingLicense) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{3, 0, 2}
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) GetLicenseId() *LicenseIdentification {
	if x != nil {
		return x.LicenseId
	}
	return nil
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) GetSecondsSinceStarted() int64 {
	if x != nil && x.SecondsSinceStarted != nil {
		return *x.SecondsSinceStarted
	}
	return 0
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) GetSecondsSinceLastPlayed() int64 {
	if x != nil && x.SecondsSinceLastPlayed != nil {
		return *x.SecondsSinceLastPlayed
	}
	return 0
}

func (x *LicenseRequest_ContentIdentification_ExistingLicense) GetSessionUsageTableEntry() []byte {
	if x != nil {
		return x.SessionUsageTableEntry
	}
	return nil
}

type ClientIdentification_NameValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          *string                `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value         *string                `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientIdentification_NameValue) Reset() {
	*x = ClientIdentification_NameValue{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientIdentification_NameValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientIdentification_NameValue) ProtoMessage() {}

func (x *ClientIdentification_NameValue) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientIdentification_NameValue.ProtoReflect.Descriptor instead.
func (*ClientIdentification_NameValue) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{6, 0}
}

func (x *ClientIdentification_NameValue) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *ClientIdentification_NameValue) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

// Capabilities which not all clients may support. Used for the license
// exchange protocol only.
type ClientIdentification_ClientCapabilities struct {
	state                      protoimpl.MessageState                               `protogen:"open.v1"`
	ClientToken                *bool                                                `protobuf:"varint,1,opt,name=client_token,json=clientToken,def=0" json:"client_token,omitempty"`
	SessionToken               *bool                                                `protobuf:"varint,2,opt,name=session_token,json=sessionToken,def=0" json:"session_token,omitempty"`
	VideoResolutionConstraints *bool                                                `protobuf:"varint,3,opt,name=video_resolution_constraints,json=videoResolutionConstraints,def=0" json:"video_resolution_constraints,omitempty"`
	MaxHdcpVersion             *ClientIdentification_ClientCapabilities_HdcpVersion `protobuf:"varint,4,opt,name=max_hdcp_version,json=maxHdcpVersion,enum=ClientIdentification_ClientCapabilities_HdcpVersion,def=0" json:"max_hdcp_version,omitempty"`
	OemCryptoApiVersion        *uint32                                              `protobuf:"varint,5,opt,name=oem_crypto_api_version,json=oemCryptoApiVersion" json:"oem_crypto_api_version,omitempty"`
	AntiRollbackUsageTable     *bool                                                `protobuf:"varint,6,opt,name=anti_rollback_usage_table,json=antiRollbackUsageTable,def=0" json:"anti_rollback_usage_table,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

// Default values for ClientIdentification_ClientCapabilities fields.
const (
	Default_ClientIdentification_ClientCapabilities_ClientToken                = bool(false)
	Default_ClientIdentification_ClientCapabilities_SessionToken               = bool(false)
	Default_ClientIdentification_ClientCapabilities_VideoResolutionConstraints = bool(false)
	Default_ClientIdentification_ClientCapabilities_MaxHdcpVersion             = ClientIdentification_ClientCapabilities_HDCP_NONE
	Default_ClientIdentification_ClientCapabilities_AntiRollbackUsageTable     = bool(false)
)

func (x *ClientIdentification_ClientCapabilities) Reset() {
	*x = ClientIdentification_ClientCapabilities{}
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientIdentification_ClientCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientIdentification_ClientCapabilities) ProtoMessage() {}

func (x *ClientIdentification_ClientCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_drm_widevine_cdm_widevine_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientIdentification_ClientCapabilities.ProtoReflect.Descriptor instead.
func (*ClientIdentification_ClientCapabilities) Descriptor() ([]byte, []int) {
	return file_drm_widevine_cdm_widevine_proto_rawDescGZIP(), []int{6, 1}
}

func (x *ClientIdentification_ClientCapabilities) GetClientToken() bool {
	if x != nil && x.ClientToken != nil {
		return *x.ClientToken
	}
	return Default_ClientIdentification_ClientCapabilities_ClientToken
}

func (x *ClientIdentification_ClientCapabilities) GetSessionToken() bool {
	if x != nil && x.SessionToken != nil {
		return *x.SessionToken
	}
	return Default_ClientIdentification_ClientCapabilities_SessionToken
}

func (x *ClientIdentification_ClientCapabilities) GetVideoResolutionConstraints() bool {
	if x != nil && x.VideoResolutionConstraints != nil {
		return *x.VideoResolutionConstraints
	}
	return Default_ClientIdentification_ClientCapabilities_VideoResolutionConstraints
}

func (x *ClientIdentification_ClientCapabilities) GetMaxHdcpVersion() ClientIdentification_ClientCapabilities_HdcpVersion {
	if x != nil && x.MaxHdcpVersion != nil {
		return *x.MaxHdcpVersion
	}
	return Default_ClientIdentification_ClientCapabilities_MaxHdcpVersion
}

func (x *ClientIdentification_ClientCapabilities) GetOemCryptoApiVersion() uint32 {
	if x != nil && x.OemCryptoApiVersion != nil {
		return *x.OemCryptoApiVersion
	}
	return 0
}

func (x *ClientIdentification_ClientCapabilities) GetAntiRollbackUsageTable() bool {
	if x != nil && x.AntiRollbackUsageTable != nil {
		return *x.AntiRollbackUsageTable
	}
	return Default_ClientIdentification_ClientCapabilities_AntiRollbackUsageTable
}

var File_drm_widevine_cdm_widevine_proto protoreflect.FileDescriptor

const file_drm_widevine_cdm_widevine_proto_rawDesc = "" +
	"\n" +
	"\x1fdrm/widevine/cdm/widevine.proto\"\xd3\x03\n" +
	"\x12WidevineCencHeader\x12;\n" +
	"\talgorithm\x18\x01 \x01(\x0e2\x1d.WidevineCencHeader.AlgorithmR\talgorithm\x12\x15\n" +
	"\x06key_id\x18\x02 \x03(\fR\x05keyId\x12\x1a\n" +
	"\bprovider\x18\x03 \x01(\tR\bprovider\x12\x1d\n" +
	"\n" +
	"content_id\x18\x04 \x01(\fR\tcontentId\x122\n" +
	"\x15track_type_deprecated\x18\x05 \x01(\tR\x13trackTypeDeprecated\x12\x16\n" +
	"\x06policy\x18\x06 \x01(\tR\x06policy\x12.\n" +
	"\x13crypto_period_index\x18\a \x01(\rR\x11cryptoPeriodIndex\x12'\n" +
	"\x0fgrouped_license\x18\b \x01(\fR\x0egroupedLicense\x12+\n" +
	"\x11protection_scheme\x18\t \x01(\rR\x10protectionScheme\x122\n" +
	"\x15crypto_period_seconds\x18\n" +
	" \x01(\rR\x13cryptoPeriodSeconds\"(\n" +
	"\tAlgorithm\x12\x0f\n" +
	"\vUNENCRYPTED\x10\x00\x12\n" +
	"\n" +
	"\x06AESCTR\x10\x01\"\xe8\x01\n" +
	"\x15LicenseIdentification\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\fR\trequestId\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\fR\tsessionId\x12\x1f\n" +
	"\vpurchase_id\x18\x03 \x01(\fR\n" +
	"purchaseId\x12 \n" +
	"\x04type\x18\x04 \x01(\x0e2\f.LicenseTypeR\x04type\x12\x18\n" +
	"\aversion\x18\x05 \x01(\x05R\aversion\x124\n" +
	"\x16provider_session_token\x18\x06 \x01(\fR\x14providerSessionToken\"\xe4\x15\n" +
	"\aLicense\x12&\n" +
	"\x02id\x18\x01 \x01(\v2\x16.LicenseIdentificationR\x02id\x12'\n" +
	"\x06policy\x18\x02 \x01(\v2\x0f.License.PolicyR\x06policy\x12'\n" +
	"\x03key\x18\x03 \x03(\v2\x15.License.KeyContainerR\x03key\x12,\n" +
	"\x12license_start_time\x18\x04 \x01(\x03R\x10licenseStartTime\x12E\n" +
	"\x1bremote_attestation_verified\x18\x05 \x01(\b:\x05falseR\x19remoteAttestationVerified\x122\n" +
	"\x15provider_client_token\x18\x06 \x01(\fR\x13providerClientToken\x1a\x91\x05\n" +
	"\x06Policy\x12 \n" +
	"\bcan_play\x18\x01 \x01(\b:\x05falseR\acanPlay\x12&\n" +
	"\vcan_persist\x18\x02 \x01(\b:\x05falseR\n" +
	"canPersist\x12\"\n" +
	"\tcan_renew\x18\x03 \x01(\b:\x05falseR\bcanRenew\x129\n" +
	"\x17rental_duration_seconds\x18\x04 \x01(\x03:\x010R\x15rentalDurationSeconds\x12=\n" +
	"\x19playback_duration_seconds\x18\x05 \x01(\x03:\x010R\x17playbackDurationSeconds\x12;\n" +
	"\x18license_duration_seconds\x18\x06 \x01(\x03:\x010R\x16licenseDurationSeconds\x12L\n" +
	"!renewal_recovery_duration_seconds\x18\a \x01(\x03:\x010R\x1erenewalRecoveryDurationSeconds\x12,\n" +
	"\x12renewal_server_url\x18\b \x01(\tR\x10renewalServerUrl\x125\n" +
	"\x15renewal_delay_seconds\x18\t \x01(\x03:\x010R\x13renewalDelaySeconds\x12F\n" +
	"\x1erenewal_retry_interval_seconds\x18\n" +
	" \x01(\x03:\x010R\x1brenewalRetryIntervalSeconds\x12/\n" +
	"\x10renew_with_usage\x18\v \x01(\b:\x05falseR\x0erenewWithUsage\x126\n" +
	"\x14renew_with_client_id\x18\f \x01(\b:\x05falseR\x11renewWithClientId\x1a\xa1\x0e\n" +
	"\fKeyContainer\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\fR\x02id\x12\x0e\n" +
	"\x02iv\x18\x02 \x01(\fR\x02iv\x12\x10\n" +
	"\x03key\x18\x03 \x01(\fR\x03key\x121\n" +
	"\x04type\x18\x04 \x01(\x0e2\x1d.License.KeyContainer.KeyTypeR\x04type\x12K\n" +
	"\x05level\x18\x05 \x01(\x0e2#.License.KeyContainer.SecurityLevel:\x10SW_SECURE_CRYPTOR\x05level\x12W\n" +
	"\x13required_protection\x18\x06 \x01(\v2&.License.KeyContainer.OutputProtectionR\x12requiredProtection\x12Y\n" +
	"\x14requested_protection\x18\a \x01(\v2&.License.KeyContainer.OutputProtectionR\x13requestedProtection\x12A\n" +
	"\vkey_control\x18\b \x01(\v2 .License.KeyContainer.KeyControlR\n" +
	"keyControl\x12|\n" +
	" operator_session_key_permissions\x18\t \x01(\v23.License.KeyContainer.OperatorSessionKeyPermissionsR\x1doperatorSessionKeyPermissions\x12q\n" +
	"\x1cvideo_resolution_constraints\x18\n" +
	" \x03(\v2/.License.KeyContainer.VideoResolutionConstraintR\x1avideoResolutionConstraints\x12@\n" +
	"\x19anti_rollback_usage_table\x18\v \x01(\b:\x05falseR\x16antiRollbackUsageTable\x1aH\n" +
	"\n" +
	"KeyControl\x12*\n" +
	"\x11key_control_block\x18\x01 \x01(\fR\x0fkeyControlBlock\x12\x0e\n" +
	"\x02iv\x18\x02 \x01(\fR\x02iv\x1a\xe6\x02\n" +
	"\x10OutputProtection\x12J\n" +
	"\x04hdcp\x18\x01 \x01(\x0e2+.License.KeyContainer.OutputProtection.HDCP:\tHDCP_NONER\x04hdcp\x12U\n" +
	"\n" +
	"cgms_flags\x18\x02 \x01(\x0e2+.License.KeyContainer.OutputProtection.CGMS:\tCGMS_NONER\tcgmsFlags\"j\n" +
	"\x04HDCP\x12\r\n" +
	"\tHDCP_NONE\x10\x00\x12\v\n" +
	"\aHDCP_V1\x10\x01\x12\v\n" +
	"\aHDCP_V2\x10\x02\x12\r\n" +
	"\tHDCP_V2_1\x10\x03\x12\r\n" +
	"\tHDCP_V2_2\x10\x04\x12\x1b\n" +
	"\x16HDCP_NO_DIGITAL_OUTPUT\x10\xff\x01\"C\n" +
	"\x04CGMS\x12\r\n" +
	"\tCGMS_NONE\x10*\x12\r\n" +
	"\tCOPY_FREE\x10\x00\x12\r\n" +
	"\tCOPY_ONCE\x10\x02\x12\x0e\n" +
	"\n" +
	"COPY_NEVER\x10\x03\x1a\xdc\x01\n" +
	"\x19VideoResolutionConstraint\x122\n" +
	"\x15min_resolution_pixels\x18\x01 \x01(\rR\x13minResolutionPixels\x122\n" +
	"\x15max_resolution_pixels\x18\x02 \x01(\rR\x13maxResolutionPixels\x12W\n" +
	"\x13required_protection\x18\x03 \x01(\v2&.License.KeyContainer.OutputProtectionR\x12requiredProtection\x1a\xda\x01\n" +
	"\x1dOperatorSessionKeyPermissions\x12*\n" +
	"\rallow_encrypt\x18\x01 \x01(\b:\x05falseR\fallowEncrypt\x12*\n" +
	"\rallow_decrypt\x18\x02 \x01(\b:\x05falseR\fallowDecrypt\x12$\n" +
	"\n" +
	"allow_sign\x18\x03 \x01(\b:\x05falseR\tallowSign\x12;\n" +
	"\x16allow_signature_verify\x18\x04 \x01(\b:\x05falseR\x14allowSignatureVerify\"J\n" +
	"\aKeyType\x12\v\n" +
	"\aSIGNING\x10\x01\x12\v\n" +
	"\aCONTENT\x10\x02\x12\x0f\n" +
	"\vKEY_CONTROL\x10\x03\x12\x14\n" +
	"\x10OPERATOR_SESSION\x10\x04\"z\n" +
	"\rSecurityLevel\x12\x14\n" +
	"\x10SW_SECURE_CRYPTO\x10\x01\x12\x14\n" +
	"\x10SW_SECURE_DECODE\x10\x02\x12\x14\n" +
	"\x10HW_SECURE_CRYPTO\x10\x03\x12\x14\n" +
	"\x10HW_SECURE_DECODE\x10\x04\x12\x11\n" +
	"\rHW_SECURE_ALL\x10\x05\"\xf2\t\n" +
	"\x0eLicenseRequest\x122\n" +
	"\tclient_id\x18\x01 \x01(\v2\x15.ClientIdentificationR\bclientId\x12D\n" +
	"\n" +
	"content_id\x18\x02 \x01(\v2%.LicenseRequest.ContentIdentificationR\tcontentId\x12/\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1b.LicenseRequest.RequestTypeR\x04type\x12!\n" +
	"\frequest_time\x18\x04 \x01(\x03R\vrequestTime\x12?\n" +
	"\x1ckey_control_nonce_deprecated\x18\x05 \x01(\fR\x19keyControlNonceDeprecated\x12H\n" +
	"\x10protocol_version\x18\x06 \x01(\x0e2\x10.ProtocolVersion:\vVERSION_2_0R\x0fprotocolVersion\x12*\n" +
	"\x11key_control_nonce\x18\a \x01(\rR\x0fkeyControlNonce\x12N\n" +
	"\x13encrypted_client_id\x18\b \x01(\v2\x1e.EncryptedClientIdentificationR\x11encryptedClientId\x1a\xd8\x05\n" +
	"\x15ContentIdentification\x12C\n" +
	"\acenc_id\x18\x01 \x01(\v2*.LicenseRequest.ContentIdentification.CENCR\x06cencId\x12C\n" +
	"\awebm_id\x18\x02 \x01(\v2*.LicenseRequest.ContentIdentification.WebMR\x06webmId\x12O\n" +
	"\alicense\x18\x03 \x01(\v25.LicenseRequest.ContentIdentification.ExistingLicenseR\alicense\x1a\x7f\n" +
	"\x04CENC\x12'\n" +
	"\x04pssh\x18\x01 \x01(\v2\x13.WidevineCencHeaderR\x04pssh\x12/\n" +
	"\flicense_type\x18\x02 \x01(\x0e2\f.LicenseTypeR\vlicenseType\x12\x1d\n" +
	"\n" +
	"request_id\x18\x03 \x01(\fR\trequestId\x1an\n" +
	"\x04WebM\x12\x16\n" +
	"\x06header\x18\x01 \x01(\fR\x06header\x12/\n" +
	"\flicense_type\x18\x02 \x01(\x0e2\f.LicenseTypeR\vlicenseType\x12\x1d\n" +
	"\n" +
	"request_id\x18\x03 \x01(\fR\trequestId\x1a\xf2\x01\n" +
	"\x0fExistingLicense\x125\n" +
	"\n" +
	"license_id\x18\x01 \x01(\v2\x16.LicenseIdentificationR\tlicenseId\x122\n" +
	"\x15seconds_since_started\x18\x02 \x01(\x03R\x13secondsSinceStarted\x129\n" +
	"\x19seconds_since_last_played\x18\x03 \x01(\x03R\x16secondsSinceLastPlayed\x129\n" +
	"\x19session_usage_table_entry\x18\x04 \x01(\fR\x16sessionUsageTableEntry\"0\n" +
	"\vRequestType\x12\a\n" +
	"\x03NEW\x10\x01\x12\v\n" +
	"\aRENEWAL\x10\x02\x12\v\n" +
	"\aRELEASE\x10\x03\"\x87\x01\n" +
	"\x11RemoteAttestation\x12@\n" +
	"\vcertificate\x18\x01 \x01(\v2\x1e.EncryptedClientIdentificationR\vcertificate\x12\x12\n" +
	"\x04salt\x18\x02 \x01(\fR\x04salt\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\"\xd2\x02\n" +
	"\rSignedMessage\x12.\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1a.SignedMessage.MessageTypeR\x04type\x12\x10\n" +
	"\x03msg\x18\x02 \x03(\fR\x03msg\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x1f\n" +
	"\vsession_key\x18\x04 \x01(\fR\n" +
	"sessionKey\x12A\n" +
	"\x12remote_attestation\x18\x05 \x01(\v2\x12.RemoteAttestationR\x11remoteAttestation\"}\n" +
	"\vMessageType\x12\x13\n" +
	"\x0fLICENSE_REQUEST\x10\x01\x12\v\n" +
	"\aLICENSE\x10\x02\x12\x12\n" +
	"\x0eERROR_RESPONSE\x10\x03\x12\x1f\n" +
	"\x1bSERVICE_CERTIFICATE_REQUEST\x10\x04\x12\x17\n" +
	"\x13SERVICE_CERTIFICATE\x10\x05\"\xfa\a\n" +
	"\x14ClientIdentification\x12;\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1f.ClientIdentification.TokenType:\x06KEYBOXR\x04type\x12\x14\n" +
	"\x05token\x18\x02 \x01(\fR\x05token\x12@\n" +
	"\vclient_info\x18\x03 \x03(\v2\x1f.ClientIdentification.NameValueR\n" +
	"clientInfo\x122\n" +
	"\x15provider_client_token\x18\x04 \x01(\fR\x13providerClientToken\x12'\n" +
	"\x0flicense_counter\x18\x05 \x01(\rR\x0elicenseCounter\x12Y\n" +
	"\x13client_capabilities\x18\x06 \x01(\v2(.ClientIdentification.ClientCapabilitiesR\x12clientCapabilities\x1a5\n" +
	"\tNameValue\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x1a\x88\x04\n" +
	"\x12ClientCapabilities\x12(\n" +
	"\fclient_token\x18\x01 \x01(\b:\x05falseR\vclientToken\x12*\n" +
	"\rsession_token\x18\x02 \x01(\b:\x05falseR\fsessionToken\x12G\n" +
	"\x1cvideo_resolution_constraints\x18\x03 \x01(\b:\x05falseR\x1avideoResolutionConstraints\x12i\n" +
	"\x10max_hdcp_version\x18\x04 \x01(\x0e24.ClientIdentification.ClientCapabilities.HdcpVersion:\tHDCP_NONER\x0emaxHdcpVersion\x123\n" +
	"\x16oem_crypto_api_version\x18\x05 \x01(\rR\x13oemCryptoApiVersion\x12@\n" +
	"\x19anti_rollback_usage_table\x18\x06 \x01(\b:\x05falseR\x16antiRollbackUsageTable\"q\n" +
	"\vHdcpVersion\x12\r\n" +
	"\tHDCP_NONE\x10\x00\x12\v\n" +
	"\aHDCP_V1\x10\x01\x12\v\n" +
	"\aHDCP_V2\x10\x02\x12\r\n" +
	"\tHDCP_V2_1\x10\x03\x12\r\n" +
	"\tHDCP_V2_2\x10\x04\x12\x1b\n" +
	"\x16HDCP_NO_DIGITAL_OUTPUT\x10\xff\x01\"S\n" +
	"\tTokenType\x12\n" +
	"\n" +
	"\x06KEYBOX\x10\x00\x12\x16\n" +
	"\x12DEVICE_CERTIFICATE\x10\x01\x12\"\n" +
	"\x1eREMOTE_ATTESTATION_CERTIFICATE\x10\x02\"\xa2\x02\n" +
	"\x1dEncryptedClientIdentification\x12\x1d\n" +
	"\n" +
	"service_id\x18\x01 \x01(\tR\tserviceId\x12I\n" +
	"!service_certificate_serial_number\x18\x02 \x01(\fR\x1eserviceCertificateSerialNumber\x12.\n" +
	"\x13encrypted_client_id\x18\x03 \x01(\fR\x11encryptedClientId\x123\n" +
	"\x16encrypted_client_id_iv\x18\x04 \x01(\fR\x13encryptedClientIdIv\x122\n" +
	"\x15encrypted_privacy_key\x18\x05 \x01(\fR\x13encryptedPrivacyKey\"\xf1\x02\n" +
	"\x14SignedLicenseRequest\x125\n" +
	"\x04type\x18\x01 \x01(\x0e2!.SignedLicenseRequest.MessageTypeR\x04type\x12!\n" +
	"\x03msg\x18\x02 \x01(\v2\x0f.LicenseRequestR\x03msg\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x1f\n" +
	"\vsession_key\x18\x04 \x01(\fR\n" +
	"sessionKey\x12A\n" +
	"\x12remote_attestation\x18\x05 \x01(\v2\x12.RemoteAttestationR\x11remoteAttestation\"}\n" +
	"\vMessageType\x12\x13\n" +
	"\x0fLICENSE_REQUEST\x10\x01\x12\v\n" +
	"\aLICENSE\x10\x02\x12\x12\n" +
	"\x0eERROR_RESPONSE\x10\x03\x12\x1f\n" +
	"\x1bSERVICE_CERTIFICATE_REQUEST\x10\x04\x12\x17\n" +
	"\x13SERVICE_CERTIFICATE\x10\x05\"\xdc\x02\n" +
	"\rSignedLicense\x12.\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1a.SignedLicense.MessageTypeR\x04type\x12\x1a\n" +
	"\x03msg\x18\x02 \x01(\v2\b.LicenseR\x03msg\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x1f\n" +
	"\vsession_key\x18\x04 \x01(\fR\n" +
	"sessionKey\x12A\n" +
	"\x12remote_attestation\x18\x05 \x01(\v2\x12.RemoteAttestationR\x11remoteAttestation\"}\n" +
	"\vMessageType\x12\x13\n" +
	"\x0fLICENSE_REQUEST\x10\x01\x12\v\n" +
	"\aLICENSE\x10\x02\x12\x12\n" +
	"\x0eERROR_RESPONSE\x10\x03\x12\x1f\n" +
	"\x1bSERVICE_CERTIFICATE_REQUEST\x10\x04\x12\x17\n" +
	"\x13SERVICE_CERTIFICATE\x10\x05*)\n" +
	"\vLicenseType\x12\r\n" +
	"\tSTREAMING\x10\x01\x12\v\n" +
	"\aOFFLINE\x10\x02*3\n" +
	"\x0fProtocolVersion\x12\x0f\n" +
	"\vVERSION_2_0\x10\x14\x12\x0f\n" +
	"\vVERSION_2_1\x10\x15B\x16Z\x14drm/widevine/cdm;cdm"

var (
	file_drm_widevine_cdm_widevine_proto_rawDescOnce sync.Once
	file_drm_widevine_cdm_widevine_proto_rawDescData []byte
)

func file_drm_widevine_cdm_widevine_proto_rawDescGZIP() []byte {
	file_drm_widevine_cdm_widevine_proto_rawDescOnce.Do(func() {
		file_drm_widevine_cdm_widevine_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_drm_widevine_cdm_widevine_proto_rawDesc), len(file_drm_widevine_cdm_widevine_proto_rawDesc)))
	})
	return file_drm_widevine_cdm_widevine_proto_rawDescData
}

var file_drm_widevine_cdm_widevine_proto_enumTypes = make([]protoimpl.EnumInfo, 13)
var file_drm_widevine_cdm_widevine_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_drm_widevine_cdm_widevine_proto_goTypes = []any{
	(LicenseType)(0),                                             // 0: LicenseType
	(ProtocolVersion)(0),                                         // 1: ProtocolVersion
	(WidevineCencHeader_Algorithm)(0),                            // 2: WidevineCencHeader.Algorithm
	(License_KeyContainer_KeyType)(0),                            // 3: License.KeyContainer.KeyType
	(License_KeyContainer_SecurityLevel)(0),                      // 4: License.KeyContainer.SecurityLevel
	(License_KeyContainer_OutputProtection_HDCP)(0),              // 5: License.KeyContainer.OutputProtection.HDCP
	(License_KeyContainer_OutputProtection_CGMS)(0),              // 6: License.KeyContainer.OutputProtection.CGMS
	(LicenseRequest_RequestType)(0),                              // 7: LicenseRequest.RequestType
	(SignedMessage_MessageType)(0),                               // 8: SignedMessage.MessageType
	(ClientIdentification_TokenType)(0),                          // 9: ClientIdentification.TokenType
	(ClientIdentification_ClientCapabilities_HdcpVersion)(0),     // 10: ClientIdentification.ClientCapabilities.HdcpVersion
	(SignedLicenseRequest_MessageType)(0),                        // 11: SignedLicenseRequest.MessageType
	(SignedLicense_MessageType)(0),                               // 12: SignedLicense.MessageType
	(*WidevineCencHeader)(nil),                                   // 13: WidevineCencHeader
	(*LicenseIdentification)(nil),                                // 14: LicenseIdentification
	(*License)(nil),                                              // 15: License
	(*LicenseRequest)(nil),                                       // 16: LicenseRequest
	(*RemoteAttestation)(nil),                                    // 17: RemoteAttestation
	(*SignedMessage)(nil),                                        // 18: SignedMessage
	(*ClientIdentification)(nil),                                 // 19: ClientIdentification
	(*EncryptedClientIdentification)(nil),                        // 20: EncryptedClientIdentification
	(*SignedLicenseRequest)(nil),                                 // 21: SignedLicenseRequest
	(*SignedLicense)(nil),                                        // 22: SignedLicense
	(*License_Policy)(nil),                                       // 23: License.Policy
	(*License_KeyContainer)(nil),                                 // 24: License.KeyContainer
	(*License_KeyContainer_KeyControl)(nil),                      // 25: License.KeyContainer.KeyControl
	(*License_KeyContainer_OutputProtection)(nil),                // 26: License.KeyContainer.OutputProtection
	(*License_KeyContainer_VideoResolutionConstraint)(nil),       // 27: License.KeyContainer.VideoResolutionConstraint
	(*License_KeyContainer_OperatorSessionKeyPermissions)(nil),   // 28: License.KeyContainer.OperatorSessionKeyPermissions
	(*LicenseRequest_ContentIdentification)(nil),                 // 29: LicenseRequest.ContentIdentification
	(*LicenseRequest_ContentIdentification_CENC)(nil),            // 30: LicenseRequest.ContentIdentification.CENC
	(*LicenseRequest_ContentIdentification_WebM)(nil),            // 31: LicenseRequest.ContentIdentification.WebM
	(*LicenseRequest_ContentIdentification_ExistingLicense)(nil), // 32: LicenseRequest.ContentIdentification.ExistingLicense
	(*ClientIdentification_NameValue)(nil),                       // 33: ClientIdentification.NameValue
	(*ClientIdentification_ClientCapabilities)(nil),              // 34: ClientIdentification.ClientCapabilities
}
var file_drm_widevine_cdm_widevine_proto_depIdxs = []int32{
	2,  // 0: WidevineCencHeader.algorithm:type_name -> WidevineCencHeader.Algorithm
	0,  // 1: LicenseIdentification.type:type_name -> LicenseType
	14, // 2: License.id:type_name -> LicenseIdentification
	23, // 3: License.policy:type_name -> License.Policy
	24, // 4: License.key:type_name -> License.KeyContainer
	19, // 5: LicenseRequest.client_id:type_name -> ClientIdentification
	29, // 6: LicenseRequest.content_id:type_name -> LicenseRequest.ContentIdentification
	7,  // 7: LicenseRequest.type:type_name -> LicenseRequest.RequestType
	1,  // 8: LicenseRequest.protocol_version:type_name -> ProtocolVersion
	20, // 9: LicenseRequest.encrypted_client_id:type_name -> EncryptedClientIdentification
	20, // 10: RemoteAttestation.certificate:type_name -> EncryptedClientIdentification
	8,  // 11: SignedMessage.type:type_name -> SignedMessage.MessageType
	17, // 12: SignedMessage.remote_attestation:type_name -> RemoteAttestation
	9,  // 13: ClientIdentification.type:type_name -> ClientIdentification.TokenType
	33, // 14: ClientIdentification.client_info:type_name -> ClientIdentification.NameValue
	34, // 15: ClientIdentification.client_capabilities:type_name -> ClientIdentification.ClientCapabilities
	11, // 16: SignedLicenseRequest.type:type_name -> SignedLicenseRequest.MessageType
	16, // 17: SignedLicenseRequest.msg:type_name -> LicenseRequest
	17, // 18: SignedLicenseRequest.remote_attestation:type_name -> RemoteAttestation
	12, // 19: SignedLicense.type:type_name -> SignedLicense.MessageType
	15, // 20: SignedLicense.msg:type_name -> License
	17, // 21: SignedLicense.remote_attestation:type_name -> RemoteAttestation
	3,  // 22: License.KeyContainer.type:type_name -> License.KeyContainer.KeyType
	4,  // 23: License.KeyContainer.level:type_name -> License.KeyContainer.SecurityLevel
	26, // 24: License.KeyContainer.required_protection:type_name -> License.KeyContainer.OutputProtection
	26, // 25: License.KeyContainer.requested_protection:type_name -> License.KeyContainer.OutputProtection
	25, // 26: License.KeyContainer.key_control:type_name -> License.KeyContainer.KeyControl
	28, // 27: License.KeyContainer.operator_session_key_permissions:type_name -> License.KeyContainer.OperatorSessionKeyPermissions
	27, // 28: License.KeyContainer.video_resolution_constraints:type_name -> License.KeyContainer.VideoResolutionConstraint
	5,  // 29: License.KeyContainer.OutputProtection.hdcp:type_name -> License.KeyContainer.OutputProtection.HDCP
	6,  // 30: License.KeyContainer.OutputProtection.cgms_flags:type_name -> License.KeyContainer.OutputProtection.CGMS
	26, // 31: License.KeyContainer.VideoResolutionConstraint.required_protection:type_name -> License.KeyContainer.OutputProtection
	30, // 32: LicenseRequest.ContentIdentification.cenc_id:type_name -> LicenseRequest.ContentIdentification.CENC
	31, // 33: LicenseRequest.ContentIdentification.webm_id:type_name -> LicenseRequest.ContentIdentification.WebM
	32, // 34: LicenseRequest.ContentIdentification.license:type_name -> LicenseRequest.ContentIdentification.ExistingLicense
	13, // 35: LicenseRequest.ContentIdentification.CENC.pssh:type_name -> WidevineCencHeader
	0,  // 36: LicenseRequest.ContentIdentification.CENC.license_type:type_name -> LicenseType
	0,  // 37: LicenseRequest.ContentIdentification.WebM.license_type:type_name -> LicenseType
	14, // 38: LicenseRequest.ContentIdentification.ExistingLicense.license_id:type_name -> LicenseIdentification
	10, // 39: ClientIdentification.ClientCapabilities.max_hdcp_version:type_name -> ClientIdentification.ClientCapabilities.HdcpVersion
	40, // [40:40] is the sub-list for method output_type
	40, // [40:40] is the sub-list for method input_type
	40, // [40:40] is the sub-list for extension type_name
	40, // [40:40] is the sub-list for extension extendee
	0,  // [0:40] is the sub-list for field type_name
}

func init() { file_drm_widevine_cdm_widevine_proto_init() }
func file_drm_widevine_cdm_widevine_proto_init() {
	if File_drm_widevine_cdm_widevine_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_drm_widevine_cdm_widevine_proto_rawDesc), len(file_drm_widevine_cdm_widevine_proto_rawDesc)),
			NumEnums:      13,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_drm_widevine_cdm_widevine_proto_goTypes,
		DependencyIndexes: file_drm_widevine_cdm_widevine_proto_depIdxs,
		EnumInfos:         file_drm_widevine_cdm_widevine_proto_enumTypes,
		MessageInfos:      file_drm_widevine_cdm_widevine_proto_msgTypes,
	}.Build()
	File_drm_widevine_cdm_widevine_proto = out.File
	file_drm_widevine_cdm_widevine_proto_goTypes = nil
	file_drm_widevine_cdm_widevine_proto_depIdxs = nil
}
